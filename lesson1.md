***

***

***

> # 备注

开场，大家好，我是高家华，很荣幸今天在这里和大家一起讨论python的性能分析

自我介绍：

- 来自腾讯反病毒实验室


- 12毕业加入腾讯


- 工作五年


- 一直从事客户端和后台的安全工作

## 课程介绍

python性能优化重不重要

在硬件越来越便宜，速度越来越快的今天，如果自己写一个python小程序，或者说在个人电脑上跑的一个一次性python任务，那么性能优化并不重要，一个小程序10s或者100s跑完，区别不大；一次性的数据处理任务，即使性能不好，也没有太多性能分析的价值。等你性能分析，性能优化一套做完，这个任务都已经做完了，以后可能再也不做这个任务了，优化也就没有意义了。

但是真实的工作场景中，越来越多的地方使用python，机器学习（人工智能）现在的技术风口啊，这里边python用的很多。Scikit-learn，TensorFlow ，还有最近也比较火的量化交易，python也用的很多。

举个我们团队的例子，我们有几百台服务器组成的分析集群来进行木马病毒分析，集群调度和分析结果处理我们都是用python实现的，里边有一些机器学习模型的应用，也是python的。我们每天处理上千万的分析任务，python的性能优化就显得很有意义了。


Python性能优化相关的课程会有三节

1. Python性能分析
2. Python性能优化的技巧及原理
3. Python性能优化实践

第一节主要讲怎么做性能分析，介绍一些性能分析的工具
第二节讲怎么做性能优化，怎么去写效率更高的python代码
第三节结合具体的例子讲性能优化实践
没有性能分析就无法进行性能优化，性能优化的技巧为解决实际问题服务，这三节课是个循序渐进的过程。
##背景知识
下边来说一下今天这节课适合的受众。整个这三堂课，属于python的初级偏中级的课程，首先需要写过一点python，没写过python直接听性能优化效果不会太好，对应不到已有知识点和技术点。大家也用担心，听懂这个课也不需要几万行python代码量那么夸张，python不像C++学习曲线那么陡峭，边写边学就可以。如果在写Python的过程中思考过一些性能问题，或者现在的学习当中就有python性能优化的需求，那就比较适合听这门课了。
那什么样的人不适合呢？刚才说过没写过python不适合，下边我展开这节课的目录，大家看下，如果都了解，也不是目标受众。
## 目录介绍
今晚的课程分成三个部分，运行时间分析，内存分析，可视化工具。运行时间这部分介绍了三种简单分析方法，shell 的time命令，python的time模块，python的timeit模块，还有两个能做详细分析的性能分析器。第二部分内存分析，讲了两个内存使用情况分析工具，其中memory_profiler比较宏观，侧重点在整体的内存占用大小。objgraph比较微观，能得到每个对象的增长情况。第三部分介绍两个可视化的工具。如果上边提到的这些东西，你都比较熟悉，就像我刚才说的，你也不适合这个课程。现在可以关了这个视频了，开两局王者荣耀去吧。

## 概述：
下边正式开始今天的课程



- 什么是性能分析：
  分析代码和它正在使用的资源之间有着怎样的关系。例如，性能分析可以告诉你一个指令或者说一段代码占用了多少CPU时间，告诉你整个程序消耗了多少内存，告诉你这个代码片段增加分配了多少内存。

  性能分析是一个很大的话题，我们今天要讨论的是python性能分析。

  ​



- 怎么做python性能分析 

  + 程序运行的速度如何
  + 时间瓶颈在哪里/内存瓶颈在哪里
  + 改进性能瓶颈

  ​

> #正文

#1. 运行时间分析
- 算法时间复杂度

  说到运行时间分析，很多人会联想到算法时间复杂度，课堂上学的老师教的对比两种算法哪个更高效靠的就是这个。
  ​

  看这个表格，里边列了常见的集中时间复杂度。

  O(1)   消耗时间固定，不随着已有数据规模而增加，不涉及到n的概念

  先说第三个线性时间，回头再说对数时间。查找无序列表的最小元素，得把所有元素遍历一遍，这就是O(n)。像二分查找，就不需要所有的遍历一遍，比较一次砍掉一半数据，数据量越大越能体现出比线性时间的优势。

  线性对数时间，快速排序的理想情况，每次选取的标杆能把当前无序 列表平均分成两块，O(nlogn)

  冒泡排序，所有数据遍历一次是线性时间，每次要找到最小的或者最大的还是线性时间，O(n**2)

  ​

  算法时间复杂度是对算法做分析的基础，但我们今天不靠理论分析，就看实际测量的值。

  ## 1.1 Shell 命令time

  今天介绍的第一个方法，也是最简单的方法，linux shell下的time命令。这个命令不仅仅用于python，可以直接测量一个shell命令的运行时间或者一个程序的运行时间，名字叫time但并不是用来显示和修改系统时间的。

  ​

  看下边这个图，ls 命令是linux下展示当前文件夹内容的命令。time命令直接测量ls命令的耗时，结果分三行，real是这个程序从开始到结束总共花了多少时间，user是cpu在用户态耗时，sys是cpu在内核态耗时。ls命令执行的比较快，下边我们换个执行的慢一点的。看这个python脚本，从0到9999做累加。time python 加脚本的名字，就能测量这个脚本的执行时间。这个脚本里边是累加操作，所以属于重计算的任务，再看下边这个脚本sleep 2s，这就不是重计算的任务，可以模拟一个重I/O的任务。

  ​

  结论：

  1. time命令首先要关注的就是real这个时间，这是程序性能最直观的展示
  2. 其次要关注user和sys加起来作为一个整体和real的关系，real 不等于user + sys，第二个脚本就是为了说明这个问题，当程序中有I/O执行，或者等待一个事件的时候，real就会大于user+sys。real 和 user + sys的值越接近，证明程序越重计算，反之说明程序更重IO。
  3. 有没有real 小于user + sys的情况呢，系统是多核并且代码优化的好有可能出现这种情况的。但这个不是重点，重点是前边说的两个。


# 内存管理

- 引用计数
- 标记清除
- 分代回收

